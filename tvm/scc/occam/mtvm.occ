PROTOCOL SCCMSG IS INT; INT::[]BYTE:

#PRAGMA EXTERNAL "PROC C.tvmspecial.1.print(VAL []BYTE buffer) = 0"

INLINE PROC c.screen.write(VAL []BYTE buffer)
  C.tvmspecial.1.print(buffer)
:

#PRAGMA EXTERNAL "PROC C.tvmspecial.2.sendString(INT dstCoreID, INT length, VAL []BYTE buffer) = 0"

INLINE PROC c.sccMesh.send(INT dstCoreID, INT length, VAL []BYTE buffer)
  C.tvmspecial.2.sendString(dstCoreID, length, buffer)
:

#PRAGMA EXTERNAL "PROC C.tvmspecial.3.recvString(INT srcCoreID, INT length, VAL []BYTE buffer, INT success) = 0"

INLINE PROC c.sccMesh.recv(INT srcCoreID, INT length, VAL []BYTE buffer, INT success)
  C.tvmspecial.3.recvString(srcCoreID, length, buffer, success)
:

#PRAGMA EXTERNAL "PROC C.tvmspecial.0.getCoreID(RESULT INT thisCoreID) = 0"

INLINE PROC c.core.id(RESULT INT thisCoreID)
  C.tvmspecial.0.getCoreID(thisCoreID)
:

PROC string.write(VAL []BYTE s, CHAN BYTE out!)
  VAL INT length IS SIZE s:
  SEQ
    SEQ i = 0 FOR length
      out ! s[i]
:

PROC integer.write(VAL INT n, CHAN BYTE out!)
  IF
    n = (MOSTNEG INT)
      string.write ("-2147483648", out!)
    n = 0
      out ! '0'
    TRUE
      VAL INT max.digits IS 20:
      [max.digits]INT D:
      INT x, i:
      SEQ
        IF
          n < 0
            x := -n
          TRUE         -- (n > 0)
            x := n
        SEQ
          i := 0
          WHILE x > 0
            SEQ
              D[i] := x\10
              x := x/10
              i := i + 1
        IF
          n < 0
            out ! '-'
        #PRAGMA DEFINED D
        WHILE i > 0
          SEQ
            i := i - 1
            out ! BYTE (D[i] + (INT '0'))
:

-- Top-level user process.
PROC tlup (CHAN BYTE scr!, CHAN SCCMSG send!, CHAN SCCMSG recv?)
  INT coreID:
  INITIAL BYTE i IS 0:  
  SEQ
    string.write("Detecting core ID...*n", scr)
    c.core.id(coreID)
    string.write("Core ID: ", scr)
    integer.write(coreID, scr)
    string.write("*n", scr)
    SEQ
      IF
        coreID = 0
          WHILE (i < 5)
            [64]BYTE str:
            SEQ
              str[0] := i + 48 
              string.write("Sending: ", scr)
              string.write([str FOR 1], scr)
              string.write("*n", scr)
              send ! 1; (SIZE str)::str
              i := i + 1
      IF
        coreID = 1
          WHILE TRUE
            INITIAL INT srcCoreID IS 0:
            INT len:
            [64]BYTE str:
            VAL []BYTE str.tmp IS "LMAO":
            SEQ
              recv ? srcCoreID; len::str
              string.write("Received: ", scr)
              string.write([str FOR len], scr)
              string.write("*n", scr)
:

-- Screen process accepting characters to be written to the screen.
PROC screen.write(CHAN BYTE in?)
  VAL INT buffer.size IS 64:
  INITIAL INT len IS 0:
  [buffer.size]BYTE buffer:
  WHILE TRUE
    BOOL flush:
    SEQ
      -- Extended rendezvous here. If there is no extended rendezvous we might
      -- loose one character of output. This might happen if:
      --  * A process send a character on screen, blocks
      --  * It gets picked up by screen handler, which runs the process again
      --    (no further code in screen handler than in ? ch is executed)
      --  * The process had sent its last character, does no more
      --    communication and does the final return. Ie the program quits
      --    but the part of the screen handler which does output has never
      --    been executed and the last character is lost
#IF DEFINED (OCCAMPI)
      in ?? buffer[len]
        SEQ
#ELSE
      in ? buffer[len]
      SEQ
        SEQ
#ENDIF
          CASE buffer[len]
            #FF
              flush := TRUE
            '*n', '*c'
              flush, len := TRUE, (len + 1)
            ELSE
              SEQ
                len   := len + 1
                flush := len >= buffer.size
          IF
            flush
              SEQ
                #PRAGMA DEFINED buffer
                c.screen.write([ buffer FOR len ])
                len := 0
            TRUE
              SKIP
:

PROC sccMesh.send(CHAN SCCMSG in?)
  INT coreID, string.length:
  [64]BYTE buffer:
  WHILE TRUE
    SEQ
      in ? coreID; string.length::buffer
      c.sccMesh.send(coreID, string.length, buffer)
:

PROC sccMesh.recv(CHAN SCCMSG out!)
  INT coreID, string.length, success:
  [64]BYTE buffer:
  WHILE TRUE
    SEQ
      coreID := 0
      c.sccMesh.recv(coreID, string.length, buffer, success)
      IF 
        success > 0
          out ! coreID; string.length::buffer
        TRUE
          RESCHEDULE()
:

-- The World running on the TVM:
--  -> the screen process to output data
--  -> the top-level user process
PROC the.world ()
  CHAN BYTE scr:
  CHAN SCCMSG snd, rcv:
  PAR
    screen.write(scr)
    sccMesh.send(snd)
    sccMesh.recv(rcv)
    tlup (scr, snd, rcv)
:
